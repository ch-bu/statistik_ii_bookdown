# Grundlagen R, R-Studio und jamovi

## Einführung

In diesem Modul beschäftigen wir uns mit den Softwares, die wir für dieses Semester verwenden werden und wir wiederholen die Inhalte aus dem Seminar Statistik I. Folgende Submodule umfasst dieses Modul:

-   Software des Seminars: In diesem Submodul erfährst du, welche Softwares wir für das Seminar verwenden und wie du diese installierst.
-   Grundlagen R: In diesem Submodul wiederholst du die grundlegenden Befehle in R und lernst, wie du mit R und R-Studio arbeiten kannst.
-   Grundlagen tidyverse: In diesem Submodul lernst du mit der Statistik-Software Jamovi umzugehen. Wir werden Jamovi in diesem Kurs verwenden, um statistische Fragestellungen zu beantworten.
-   Quiz Statistik I: An dieser Stelle wiederholst du zentrale Konzepte aus Statistik I, die Vorraussetzung für dieses Seminar sind.

## Software des Seminars

Wir werden in diesem Kurs drei Softwares verwenden. R, R-Studio und Jamovi. R und R-Studio verwenden wir, um Daten zu bereinigen, deskriptive Daten zu berechnen und die Ergebnisse unserer Tests zu dokumentieren. Jamovi verwenden wir, um statistische Fragestellungen zu beantworten. Beide Softwares lassen sich miteinander integrieren, indem wir Ergebnisse aus Jamovi als Code in R übertragen können. Der Vorteil dieser Übertragung ist, dass du hierdurch keine Befehle in R lernen musst und dadurch ohne große Mühe statistische Testverfahren in R rechnen kannst. In diesem Modul lernst du diejenigen Kentnisse in R und Jamovi, die wir in diesem Seminar immer wieder brauchen.

-   [R](https://www.r-project.org/): R ist eine statistische Programmiersprache zur Analyse von Daten. Mit R werden wir in diesem Kurs Daten bereinigen und visualisieren. Datenvisualisierung ist ein zentraler Bestandteil der Datenanalyse, da wir durch Visualisierungen Muster in Daten erkennen können, die aus den Rohdaten schwer zu entnehmen sind. Zudem verwenden wir R für die Dokumentation unserer Ergebnisse. Die Dokumentation ist wichtig, da wir auch Jahre nach unserer Analyse verstehen möchten, wie wir die Daten ausgewertet haben. In SPSS oder Jamovi ist dies deutlich unübersichtlicher.
-   [R-Studio](https://rstudio.com/): R-Studio ist eine Entwicklungsumgebung für die Programmiersprache R. Sie umfasst eine grafische Benutzeroberfläche und vereinfacht die Arbeit mit R.
-   [Jamovi](https://www.jamovi.org/): Jamovi ist eine Software mit der man die gängigsten statistischen Verfahren in einer grafischen Benutzeroberfläche berechnen kann. In diesem Kurs verwenden wir Jamovi zur Berechnung der Verfahren und werden deren Ergebnisse in R übertragen. Zwar wird in der empirischen Sozialforschung häufig SPSS eingesetzt, allerdings ist SPSS kostenpflichtig und umfasst viele Verfahren, die wir in diesem Kurs nicht benötigen. Jamovi hat den Vorteil, dass es kostenlos ist und eine ähnliche Oberfläche wie SPSS hat. Der Transfer zu SPSS ist daher relativ einfach. Ein weiterer Grund für Jamovi ist, dass es sich sehr einfach mit R integrieren lässt.

## Download der Software

Die drei Softwares sind unter folgenden Links kostenfrei für Mac und Windows zugänglich. Lade dir die Softwares gleich jetzt herunter. Wir werden alle drei Softwares in jedem Modul des Kurses verwenden.

-   [R \> 4.0.2](https://ftp.gwdg.de/pub/misc/cran/): Lade R in der Version 4.0.2 oder größer herunter.
-   [R-Studio](https://rstudio.com/products/rstudio/download/): Lade die neueste Version von R-Studio herunter.
-   [Jamovi 1.2 solid](https://www.jamovi.org/download.html): Lade die Version 1.1.9 solid von Jamovi herunter.

## Warum so viele Softwares?

Es ist heutzutage nicht mehr möglich Statistik ohne Software zu betreiben. Wir werden in diesem Kurs versuchen, diejenigen Softwares zu verwenden, mit denen du am einfachsten Daten analysieren und statistische Verfahren berechnen kannst. Ein paar Fragen könntest du dir an dieser Stelle dennoch stellen:

-   **Warum überhaupt R?** Keine Datenanalyse kommt ohne die Verarbeitung von Daten aus. Stell dir beispielsweise vor du möchtest neue Variablen berechnen bzw. ein Balkendiagramm erstellen. Solche Datenveränderungen und Visualisierungen lassen sich in R sehr elegant mit dem Paket[tidyverse](https://www.tidyverse.org/)umsetzen. Zudem ermöglicht uns das Paket[ggplot2](https://ggplot2.tidyverse.org/) die Visualisierung von Daten. R ist zudem kostenfrei und kann sowohl auf Mac als auch auf Windows installiert werden.

-   **Warum nicht alles in R?** R hat für Beginner eine steile Lernkurve. Viele statistische Verfahren lassen sich direkt in R berechnen (z.B.[psych](https://cran.r-project.org/web/packages/psych/index.html),[car](https://cran.r-project.org/web/packages/car/index.html)), jedoch muss man hierfür häufig mehrere Pakete installieren und diese ebenso anwenden können. Wir vermeiden dies in diesem Kurs, indem wir die Analysen in Jamovi umsetzen.

-   **Warum nicht alles in SPSS?** SPSS ist eine in der Sozialforschung beliebte Software, um statistische Verfahren zu rechnen. SPSS ist allerdings kostenpflichtig. Da es kostenfreie Alternativen gibt, die alle Verfahren dieses Kurses abdecken, rechnen wir mit Jamovi. Wenn man Jamovi verstanden hat, ist der Transfer zu SPSS einfach.

## Grundlagen R

In diesem Submodul lernst du zentrale Befehle in R, welche du immer wieder verwenden wirst. Genauer gehen wir auf folgende Themen ein:

-   Umgang mit R-Studio

-   Pakete installieren und laden

-   Das Arbeitsverzeichnis

-   Datensätze importieren

-   Grundlegende Operatoren in

    -   R Rechenoperationen

    -   Zuordnungsoperator

    -   Der == Operator

-   Funktionen Grundlegende Funktionen in R

    -   View

    -   colnames

    -   nrow

    -   ncol

    -   head

-   Daten exportieren

### Umgang mit R-Studio

R-Studio ist eine Entwicklungsumgebung für die Programmiersprache R. R-Studio vereinfacht dir die Arbeit mit R, indem es beispielsweise einen Editor integriert, in welchen du R-Code schreiben kannst. R-Studio hat vier zentrale Fenster:

![](images/02_grundlagen/rstudio_panels.jpg "Die vier zentralen Fenster von R-Studio")

-   Im Skript links oben findest du die R-Skripte. Dort speicherst du diejenigen Befehle, welche du auf jeden Fall speichern möchtest. Beispielsweise ein statistisches Verfahren, mit welchem du eine Hypothesen prüfst oder eine Visualisierung, die du erstellt hast.

-   In der Konsole links unten probierst du verschiedene Befehle aus. Die Konsole ist flüchtig und daher kein Ort, um dauerhaft Berechnungen zu sichern. Hierfür verwendest du am besten das Skript.

-   Das Environment und die History im Fenster rechts oben ist für diesen Kurs weniger relevant. Im Environment siehst du, auf welche Variablen und Daten du zugreifen kannst.

-   Rechts unten findest du den Output und die Plots/Visualisierungen. In der Regel schaust du hier deine Visualisierungen an, die du im Skript bzw. in der Konsole erstellst.

### Befehle aus der Konsole ausführen

Befehle lassen sich sowohl in der Konsole als auch im Skript ausführen. Als Faustregel: Die Konsole dient dem Herumspielen mit den Daten, im Skript schreibst du alle Befehle auf, die du gerne behalten möchtest. Nehmen wir an, du möchtest die Zahl 5 mit der Zahl 8 addieren:

```{r}
5 + 8
```

Um den Befehl in der Konsole auszuführen, drückst du die **ENTER-Taste**

Anschließend erhältst du das Ergebnis der Berechnung. Um diesen Output aus der Konsole wieder zu entfernen, kannst du die Tastenkombination **STRG+L** verwenden. Hierdurch verschwindet der Output:

![](images/02_grundlagen/console.png)

Wenn du eine Grafik erstellst (den Code musst du an dieser Stelle nicht verstehen), wird der Output in dem Plots Panel angezeigt, ohne dass du in der Konsole einen Output erhältst:

![](images/02_grundlagen/plot.png)

### Befehle aus dem Skript ausführen

Genau die gleichen Befehle kannst du aus einem Skript ausführen (Um ein neues Skript zu öffnen drücke **STRG + UMSCHALT + N** auf deiner Tastatur):

![](images/02_grundlagen/befehle_skrip.jpg)

Um diesen Befehl auszuführen, musst du Deinen Cursor auf die jeweilige Zeile legen und **STRG+ENTER** drücken (für Mac-Nutzer: command + enter):

![](images/02_grundlagen/befehle_skript1.png)

Wenn du ENTER-Taste nicht drückst, springt der Cursor in die nächste Zeile, ohne dass der Befehl ausgeführt wird. Alternativ kannst du die Zeile ausführen, indem du den Button Run drückst:

![](images/02_grundlagen/run.png)

Um mehrere Zeilen ausführen, musst du mehrere Zeilen selektieren und STRG+ENTER drücken:

![](images/02_grundlagen/multi_run.jpg)

### Pakete installieren und laden

Ein Paket ist eine Sammlung an Funktionen und Daten, welche du gebündelt herunterladen kannst. Pakete erweitern die Funktionalität von R. R hat bereits viele Funktionen, die wir für die Datenanalyse verwenden können. Beispielsweise umfasst R die Funktion mean, mit der wir Mittelwerte aus einer Variablen berechnen können. Selbst wenn R hunderte Funktionen hat, die mit R mitgeliefert werden, brauchen wir häufig weitere Funktionen, um unsere Daten zu analysieren. Für diesen Kurs benötigen wir insbesondere Pakete, mit denen wir Daten analysieren, visualisieren und auswerten können. In diesem Kurs verwenden wir folgende Pakete:

-   [tidyverse](https://rise.articulate.com/author/SHojwTyVccfVjJhG_D37L6cXrgxGbnca#/author/details/anYDnxw9kjDldfma4gUcOvsHCpVUSe5-): Tidyverse umfasst eine Vielzahl an Paketen zur Analyse und Verarbeitung von Daten. Die Pakete haben eine einheitliche Philosophie und arbeiten reibungslos miteinander.

-   [jmv \>= 1.2.23](https://cran.r-project.org/web/packages/jmv/index.html): jmv ist ein Paket, welches mit Jamovi zusammen arbeitet und uns ermöglicht, die Analysen, die wir in Jamovi umgesetzt haben, in R zu übertragen.

-   [janitor](https://github.com/sfirke/janitor): Viele Datensätze sind unstrukturiert und enthalten komplexe Variablennamen. Mit dem Paket janitor können wir diese bereinigen.

-   [styler](https://github.com/r-lib/styler): Mit styler können wir unseren Code so formatieren, dass er den Gestaltungsrichtlinien entspricht. Beispielsweise möchten wir nicht, dass eine Zeile Code länger als 80 Zeilen ist. Mit Hilfe von styler können wir solche Fehler durch einen Klick korrigieren.

Du kannst zu jeder Zeit in R-Studio sehen, welche Pakete installiert sind, indem du dir den Package Panel anschaust (rechts unten in R-Studio):

![](images/02_grundlagen/pakete.png)

#### Pakete intallieren

Um Pakete zu installieren, kannst du in R-Studio auf Install unter dem Fenster Packages klicken:

![](images/02_grundlagen/install_pakete.png)

Trage zunächst das Paket unter Packages ein und drücke anschließend auf Install. Installiere sowohl tidyverse, janitor, jmv als auch styler. Alternativ kannst du direkt den Befehl in die Konsole eingeben, um die Pakete zu installieren (führe die Befehle am besten nacheinander aus):

    >     install.packages("tidyverse")
    >     # Dann
    >     install.packages("janitor")
    >     # Dann
    >     install.packags("jmv")
    >     # Dann
    >     install.packags("styler")

Prüfe anschließend, ob alle Pakete installiert wurden. Suche hierfür die Pakete in dem Panel Packages:

![](images/02_grundlagen/pakete_check.png)

#### Pakete laden

Um die Funktionalität eines Paketes verwenden zu können, ist es mit der Installation nicht getan. Wir müssen die Pakete zusätzlich laden. Am besten lädst du die Pakete immer am Anfang deines R-Skripts, indem du folgende Befehl für jedes Paket eingibst:

    >     library(tidyverse)
    >     library(jmv)

Um anschließend zu prüfen, welche Pakete gerade geladen sind, kannst du den Befehl sessionInfo() ausführen: 

    > sessionInfo()

TODO: hier ist die Schrift irgendwie anders (bei sessionInfo), aber ich kann es nicht umstellen.

    >     R version 3.6.1 (2019-07-05)
    >     ## Platform: x86_64-w64-mingw32/x64 (64-bit)
    >     ## Running under: Windows 10 x64 (build 17763)
    >     ## 
    >     ## Matrix products: default
    >     ## 
    >     ## locale:
    >     ## [1] LC_COLLATE=German_Germany.1252  LC_CTYPE=German_Germany.1252   
    >     ## [3] LC_MONETARY=German_Germany.1252 LC_NUMERIC=C                   
    >     ## [5] LC_TIME=German_Germany.1252    
    >     ## 
    >     ## attached base packages:
    >     ## [1] stats     graphics  grDevices utils     datasets  methods   base     
    >     ## 
    >     ## other attached packages:
    >     ##  [1] jmv_1.0.8       forcats_0.4.0   stringr_1.4.0   dplyr_0.8.3    
    >     ##  [5] purrr_0.3.3     readr_1.3.1     tidyr_1.0.0     tibble_2.1.3   
    >     ##  [9] ggplot2_3.2.1   tidyverse_1.2.1
    >     ## 
    >     ## loaded via a namespace (and not attached):
    >     ##  [1] tidyselect_0.2.5 xfun_0.10        haven_2.1.1      lattice_0.20-38 
    >     ##  [5] colorspace_1.4-1 vctrs_0.2.1      generics_0.0.2   htmltools_0.4.0 
    >     ##  [9] yaml_2.2.0       rlang_0.4.2      pillar_1.4.3     glue_1.3.1      
    >     ## [13] withr_2.1.2      modelr_0.1.5     readxl_1.3.1     jmvcore_1.0.8   
    >     ## [17] lifecycle_0.1.0  munsell_0.5.0    gtable_0.3.0     cellranger_1.1.0
    >     ## [21] rvest_0.3.4      evaluate_0.14    knitr_1.25       fansi_0.4.0     
    >     ## [25] broom_0.5.2      Rcpp_1.0.3       backports_1.1.5  scales_1.1.0    
    >     ## [29] jsonlite_1.6     rjson_0.2.20     hms_0.5.2        digest_0.6.23   
    >     ## [33] stringi_1.4.3    bookdown_0.14    grid_3.6.1       cli_2.0.0       
    >     ## [37] tools_3.6.1      magrittr_1.5     lazyeval_0.2.2   crayon_1.3.4    
    >     ## [41] pkgconfig_2.0.3  zeallot_0.1.0    xml2_1.2.2       lubridate_1.7.4 
    >     ## [45] assertthat_0.2.1 rmarkdown_1.16   httr_1.4.1       rstudioapi_0.10 
    >     ## [49] R6_2.4.1         nlme_3.1-142     compiler_3.6.1

Unter loaded via namespace kannst du erkennen, welche Pakete installiert sind, aber nicht geladen sind. Unter other attached packages siehst du, welche Pakete geladen sind, beispielsweise jmv. Erst nachdem ein Paket geladen ist, kannst du die Funktionen der Pakete verwenden. Wenn du R-Studio neu startest, muss jedes Paket immer neu geladen werden. Diesen Schritt vergisst man häufig, wodurch Fehler entstehen. Stelle daher immer sicher, dass du die nötigen Pakete lädst, bevor du Funktionen der Pakete verwendest. Um zu prüfen, aus welchem Paket eine Funktion stammt, setze ein Fragezeichen vor die Funktion (siehe nächstes Bild links oben). Anschließend siehst du die Dokumentation dieses Befehls in dem Panel Help:

![](images/02_grundlagen/panel_help.jpg)

### Das Arbeitsverzeichnis

Wenn du R öffnest, legt R im Hintergrund immer einen Ordner fest, aus dem du alle Dateien importierst und exportierst. Diesen Ordner nennt man das Arbeitsverzeichnis. Du kannst dir das Arbeitsverzeichnis in R anzeigen lassen, indem du folgenden Befehl in der Konsole ausführst:

    >     getwd()

Als Output erhältst du das Verzeichnis des Ordners, welcher gerade als Arbeitsverzeichnis bestimmt ist:

    >     [1] "C:/Users/Christian/Lehre/2020_ws_statistik_II"

Solange du in R nicht mit [Projekten](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects) arbeitest, musst du wissen, wo das Arbeitsverzeichnis liegt, um Dateien zu importieren. Wenn du beispielsweise folgenden Befehl verwendest, um die Datei human_resources.csv einzulesen, nimmt R automatisch an, dass sich diese Datei im Arbeitsverzeichnis befindet:

    >     # Nehmen wir an, dass sich das Arbeitsverzeichnis 
    >     # in folgendem Ordner befindet: 
    >     #    C:/Users/Christian/Dropbox/Lehre
    >     human_resources <- read_csv("human_resources.csv")

Der Text zwischen den Anführungszeichen wird auch als relativer Pfad bezeichnet. Liegt die Datei beispielsweise einen Ordner über dem Arbeitsverzeichnis (in unserem Beispiel im Ordner Dropbox), verwenden wir zwei Punkte, um einen Ordner nach oben zu klettern:

    >     # Nehmen wir an, dass sich das Arbeitsverzeichnis 
    >     # in folgendem Ordner befindet: 
    >     #    C:/Users/Christian/Dropbox/Lehre
    >     human_resources <- read_csv("../human_resources.csv")

Nun sucht R die Datei *human_resources.csv* im Ordner Dropbox. Die einfachste Methode, um allerdings eine Datei zu importieren, ist, das Arbeitsverzeichnis dort festzulegen, wo die Datei gespeichert ist. Dies können wir tun, indem wir den Shortcut **Ctrl+ UMSCHALT + H** in R-Studio ausführen. Danach öffnet sich ein Fenster, in dem wir das Arbeitsverzeichnis bestimmen können.

### Datensätze importieren

In diesem Kurs arbeiten wir mit Daten, die in Tabellen angeordnet sind. Häufig liegen Daten als Excel-Dateien vor. Ein gängiges Format, um Daten zu speichern sind allerdings [CSV-Dateien](https://de.wikipedia.org/wiki/CSV_(Dateiformat)). CSV steht für Comma Seperated Values. Dies bedeutet, dass Werte in CSV-Dateien entweder durch ein Komma oder ein Semikolon getrennt sind. In folgendem Beispiel siehst du ein Datensatz mit drei Variablen, die in jeder Reihe durch ein Komma getrennt sind:

    >     id,variable1,variable2
    >     ku22su99,2,3
    >     nn08se21,5,6

TODO: Hier soll eigentlich eine Bildunterschrift hin mit "Beispiel einer CSV-Datei". Ich wusste nicht wie ich das einfüge, wenn es kein Bild ist.

Da CSV-Dateien ein sehr bekanntes Dateiformat für Daten sind, lassen sich CSV-Dateien sowohl in Excel, Jamovi, SPSS, als auch R importieren ([Excel](https://support.microsoft.com/de-de/office/importieren-oder-exportieren-von-textdateien-txt-oder-csv-5250ac4c-663c-47ce-937b-339e391393ba?ui=de-de&rs=de-de&ad=de), [SPSS](https://www.youtube.com/watch?v=-imCiECplPo), [Jamovi](https://www.youtube.com/watch?v=R0uE4LlHeac)). Wir werden in diesem Modul mit dem Datensatz *human_resources.csv* arbeiten. Den Datensatz kannst du dir unter folgendem Link herunter laden:

TODO: Hier kommt eine Datei rein. Ich wusste nicht wie ich sie einfüge. human_resources.csv

Eine CSV-Datei können wir in R importieren, indem wir die Datei in dem *Panel Files* suchen und auf die Datei klicken. Klicke anschließend auf auf *Import Dataset*:

![](images/02_grundlagen/csv_.png)

Anschließend siehst du ein neues Fenster, in welchem der Code angezeigt wird, mit dem wir die Daten importieren können. Kopiere am einfachsten die zweite Zeile des Code Preview (gelb markiert) und drücke dann auf Cancel. 

Falls die Daten nicht sauber in Spalten angeordnet sind, kannst du unter dem Reiter *Delimiter* die Trennzeichen ändern. Im folgenden Beispiel sind die Trennzeichen in der CSV-Datei Kommas.

![](images/02_grundlagen/table.jpg)

Diesen kopierten Code fügst du in dein R-Skript ein. Achte darauf, dass du vorher das Paket tidyverse lädst: 

![Beispiel für das Laden eines Datensatzes mit dem Paket tidyverse](images/02_grundlagen/load_dataset.jpg)

Im nächsten Schritt liest du den Datensatz ein, indem du den Befehl ausführst:

![](images/02_grundlagen/load_data1.png)

Die rote Schrift hat keine Bedeutung. Sie zeigt an, welche Variablen der Datensatz umfasst. Um zu prüfen, ob der Datensatz in der Variable gespeichert wurde, gib den Datensatz in der Konsole aus:

![](images/02_grundlagen/enviroment.png)

Gleichzeitig kannst du im Panel Environment sehen, ob dein Datensatz geladen wurde:

![](images/02_grundlagen/environment1.png)

Der Output zeigt uns an, dass der Datensatz 1470 Reihen und 17 Variablen hat.

### Grundlegende Operatoren in R

#### Rechenoperationen

R umfasst die typischen Rechenoperatoren, die du aus der Schule kennst. Du kannst mit R Plus, Minus oder Geteilt rechnen.

Zahlen voneinander teilen:

```{r}
3 / 9
```

Das Produkt zweier Zahlen berechnen:

```{r}
3 * 4
```

Zwei Zahlen miteinander addieren:

```{r}
3 + 4 
```

Die Zeichen +, -, / oder \* nennen wir Operatoren. Operatoren sind nichts anderes als besondere Symbole, die eine bestimmte Aufgabe haben. Zum Beispiel hat der Operator + die Aufgabe, zwei Zahlen zu addieren. Wir können ebenso mehrere Operatoren miteinander verschachteln:

```{r}
(3 / 9) * 4 + 3
```

#### Der Zuordnungsoperator

Der Zuordnungsoperator \<- wird verwendet, um Variablen zu kreiieren. Variablen kannst du dir wie Boxen bei einem Umzug vorstellen, die etwas enthalten. Jede Box bekommt ein Label, hier einen Variablennamen. Was in der Box steckt, kannst du erfahren, indem du die Box aufmachst, bzw. dir die Variable in R ausgeben lässt. Erstellen wir hierzu eine neue Variable mit dem Namen sum_score:

    >     sum_score <- 3 + 4

Jede Variable umfasst drei Elemente:

1.  **Der Variablenname**: sum_score beispielsweise. Dieser Name ist willkürlich. Er sollte nicht mit einer Zahl beginnen und kleingeschrieben sein. Trenne mehrere Wörter am besten mit einem Unterstrich (z.B. sum_score).

2.  **Der Zuordnungsoperator \<-:** Achte darauf, dass vor dem \< und hinter dem - ein Leerzeichen steht. Ebenso sollte zwischen Operatoren ein Leerzeichen stehen. Falsch: sum_score\<-3+4, falsch: sum_score \<- 3+4, richtig: sum_score \<- 3 + 4.

3.  **Der Inhalt der Variable:** 3 + 4. Der Inhalt kann im Prinzip alles sein: Text: "Hallo", ein Datensatz: read_csv(...) oder der Output einer Funktion: mean(c(1, 3, 4))

Wenn du eine Variable erstellst, passiert zunächst nichts. R speichert intern das Produkt in der Variable sum_score. Um das Ergebnis der Berechnung zu sehen, führe die Variable in R aus:

    >     sum_score

    >     ## [1] 7

Variablennamen sollten immer so geschrieben sein, dass man weiß, was in der Variable steckt:

    >     x <- 3 + 2 # schlecht
    >     summe_zahlen <- 3 + 2 # besser

Trenne einzelne Wörter in der Variable mit einem Unterstrich:

    >     my_age <- 24  # gut
    >
    >     my.age <- 24 # schlecht
    >     my-age <- 24 # schlecht
    >     my/age <- 24 # schlecht

Schreibe Variablen am besten alle Buchstaben des Variablennamen in Kleinschreibung:

    >     my_age <- 24
    >     # nicht:
    >     My_age <- 24

Variablen sollten exakt angegeben werden. Kleinste Fehler führen zu Fehlern. Zum Beispiel macht die Groß- oder Kleinschreibung einen Unterschied:

    >     > my_age <- 24
    >     > My_age
    >     Error: object 'My_age' not found

#### Der == Operator

Wir können ebenso prüfen, ob zwei Werte gleich sind, indem wir den == Operator verwenden:

```{r}
3 == 4
```

Oder:

```{r}
3 == 3
```

Oder:

```{r}
3 == 1 + 2
```

Später werden wir diesen Operator verwenden, um Reihen in einem Datensatz zu filtern. Eine volle Liste der restlichen Operatoren findest du [hier](https://www.statmethods.net/management/operators.html).

### Funktionen

Jede Programmiersprache ist nur so umfangreich, wie viele Funktionen sie hat. Funktionen werden von Menschen geschrieben, deren Ziel es ist, verschiedenste Berechnungen zu automatisieren. Gib zum Beispiel einmal in deine Konsole nur die Funktion mean ein. Was du erhältst ist der Beginn einer Funktion, die Menschen für die Programmiersprache R geschrieben haben. Funktionen haben immer den gleichen Aufbau:

    >     function_name(argument1 = value1, argument2 = value2)

-   **function_name**: Dies ist der Name der Funktion. Auch dieser ist wie bei Variablen willkürlich gewählt.

-   **argument1**: Funktionen haben immer Argumente. Ein Argument besagt, welche Objekte in eine Funktion gespeist werden. Stell dir Funktionen wie eine Fabrik vor, die etwas herstellt. Jede Fabrik benötigt Rohmaterial mit dem Produkte erzeugt werden. Argumente sind äquivalent zu Rohmaterialien. Sie werden in die Funktion gespeist und in der Funktion verarbeitet.

-   **value1**: Jedes dieser Rohmaterialien hat bestimmte Werte. Beispielsweise kann value1 eine Zahl (3) oder ein Text sein ("Hallo"). Wir werden später andere Datentypen kennen lernen, die ebenso in Funktionen gespeist werden können (z.B. Vektoren oder Dataframes - mehr dazu gleich).

Beispielsweise umfasst R die Funktion sqrt mit der wir die Wurzel einer Zahl berechnen können:

```{r}
sqrt(9)
```

Mit Hilfe des ? Zeichens können wir die Funktion näher betrachten und uns ansehen, welche Argumente eine Funktion annimmt:

![](images/02_grundlagen/funktion.png)

Die Funktion sqrt hat demnach nur ein Argument mit dem Namen x. x kann sowohl eine einzelne Zahl als auch mehrere Zahlen sein. Wir müssen das Argument nicht immer angeben. Wir hätten die Funktion daher auch so formulieren können:

```{r}
sqrt(x = 9)
```

Achte darauf, dass jede Funktion mit einer Klammer schließt. Tust du dies nicht, denkt R, dass dein Befehl noch nicht zu Ende ist und zeigt Dir dies mit einem + an:

    >     > sqrt(9
    >     +

Eine andere Funktion heißt sum. Mit sum kannst du mehrere Zahlen miteinander addieren:

```{r}
sum(3, 4, 5)
```

Wenn du dir die Funktion unter der Hilfe mit ?sum anschaust, erkennst du, dass die Funktion unendlich viele Argumente hat. Dies wird mit einem ... gekennzeichnet:

![](images/02_grundlagen/sum.png)

Wir könnten daher ebenso die Summe von fünf Zahlen zusammen rechnen:

```{r}
sum(1, 2, 3, 4, 5)
```

Lade als nächstes das Paket tidyverse (library(tidyverse)). Das Paket tidyverse umfasst die Funktion select. Mit Hilfe von select werden wir später Variablen aus einem Datensatz selektieren. Wenn du dir die Dokumentation der Funktion mit Hilfe von ?select anschaust, erkennst du, dass die Funktion mehrere Argumente hat:

![](images/02_grundlagen/select.png)

Das erste Argument heißt .data. Hierfür fügen wir später den Datensatz ein. Das zweite Argument hat keinen expliziten Namen, sondern umfasst eine mit Komma getrennte Liste an Variablennamen. Schauen wir uns ein Beispiel an. Hierfür laden wir zunächst das Paket tidyverse und den Datensatz *human_resources*:

    >     library(tidyverse)
    >     human_resources <- read_csv("human_resources.csv")

Anschließend können wir die Funktion select ausführen, um verschiede Variablen aus dem Datensatz zu nehmen (Um zu sehen, welche Variablen im Datensatz stecken, gebe colnames(human_resources) in die Konsole ein):

    >     select(.data = human_resources, id, age)

    >     ## # A tibble: 1,470 x 2
    >     ##       id   age
    >     ##    <dbl> <dbl>
    >     ##  1     1    41
    >     ##  2     2    49
    >     ##  3     3    37
    >     ##  4     4    33
    >     ##  5     5    27
    >     ##  6     6    32
    >     ##  7     7    59
    >     ##  8     8    30
    >     ##  9     9    38
    >     ## 10    10    36
    >     ## # … with 1,460 more rows

Du erkennst das erste Argument .data, in welches wir den Datensatz einfügen. Zusätzlich geben wir mehrere Variablennamen ein, indem wir die Variablennamen durch ein Komma trennen. Wir hätten ebenso die Argumente umdrehen können:

    >     select(id, age, .data = human_resources)

    >     ## # A tibble: 1,470 x 2
    >     ##       id   age
    >     ##    <dbl> <dbl>
    >     ##  1     1    41
    >     ##  2     2    49
    >     ##  3     3    37
    >     ##  4     4    33
    >     ##  5     5    27
    >     ##  6     6    32
    >     ##  7     7    59
    >     ##  8     8    30
    >     ##  9     9    38
    >     ## 10    10    36
    >     ## # … with 1,460 more rows

Generell ist es allerdings ratsam, die Reihenfolge der Argumente beizubehalten. Wenn wir dies tun, können wir die Namen der Argumente ignorieren:

    >     select(human_resources, id, age)

Versuchen wir nochmal von diesem Beispiel zu abstrahieren. Funktionen haben einen Namen und eine umgebende Klammer:

    >     function_name()

Fasst alle Funktionen haben Argumente. Die Anzahl der Argumente ist abhängig von der Funktion. Hier siehst du das Schema einer Funktion mit zwei Argumenten:

    >     function_name(argument1 = value1, argument2 = value2)

Die Reihenfolge der Argumente ist egal, solange wir die Argumente explizit benennen:

    >     function_name(argument2 = value2, argument1 = value1)

Bennenen wir die Argumente nicht, müssen wir die Reihenfolge beachten, die in der Funktion (siehe ?function_name) vorgegeben ist:

    >     function_name(value1, value2)

### Grundlegende Funktionen in R

Es gibt ein paar wenige Befehle, die du immer wieder in R benötigst. Wir werden die Befehle anhand des Datensatzes *human_resources.csv* kennen lernen, den du hier herunterladen kannst:

TODO: Einfügen Datei: human_resources.csv

Zunächst müssen wir tidyverse laden und den Datensatz importieren:

    >     library(tidyverse)
    >     human_resources <- read_csv("human_resources.csv")

Mit [View](https://www.rdocumentation.org/packages/utils/versions/3.6.1/topics/View)kannst du Dir den Datensatz in einem Excel-ähnlichen Format betrachten:

    >     View(human_resources)

![](images/02_grundlagen/view_hr.png)

Du kannst dir die Variablennamen mit der Funktion colnames ausgeben lassen:

    >     colnames(human_resources)

    >     ##  [1] "id"                         "age"                       
    >     ##  [3] "department"                 "distance_from_home"        
    >     ##  [5] "education"                  "employee_count"            
    >     ##  [7] "gender"                     "job_role"                  
    >     ##  [9] "job_satisfaction"           "marital_status"            
    >     ## [11] "monthly_income"             "num_companies_worked"      
    >     ## [13] "performance_rating"         "total_working_years"       
    >     ## [15] "work_life_balance"          "years_at_company"          
    >     ## [17] "years_since_last_promotion"

Manchmal möchte man wissen, wie viele Reihen in einem Datensatz stecken. Hierfür kannst du die Funktion [nrow](https://www.rdocumentation.org/packages/base/versions/3.6.1/topics/nrow)verwenden:

    >     nrow(human_resources)

    >     ## [1] 1470

Genausogut lassen sich die Anzahl der Variablen (bzw. Spalten) in einem Datensatz mit der Funktion [ncol](https://www.rdocumentation.org/packages/base/versions/3.6.1/topics/nrow)ausgeben lassen:

    >     ncol(human_resources)

    >     ## [1] 17

Zuletzt benötigen wir noch die Funktion head. Mithilfe von head können wir uns die ersten Reihen eines Datensatzes ansehen:

    >     head(human_resources)

    >     ## # A tibble: 6 x 17
    >     ##      id   age department distance_from_h… education employee_count gender
    >     ##   <dbl> <dbl> <chr>                 <dbl> <chr>              <dbl> <chr> 
    >     ## 1     1    41 Sales                     1 College                1 Female
    >     ## 2     2    49 Research …                8 Below Co…              1 Male  
    >     ## 3     3    37 Research …                2 College                1 Male  
    >     ## 4     4    33 Research …                3 Master                 1 Female
    >     ## 5     5    27 Research …                2 Below Co…              1 Male  
    >     ## 6     6    32 Research …                2 College                1 Male  
    >     ## # … with 10 more variables: job_role <chr>, job_satisfaction <chr>,
    >     ## #   marital_status <chr>, monthly_income <dbl>,
    >     ## #   num_companies_worked <dbl>, performance_rating <chr>,
    >     ## #   total_working_years <dbl>, work_life_balance <chr>,
    >     ## #   years_at_company <dbl>, years_since_last_promotion <dbl>

#### Daten exportieren

Wenn wir Daten importieren möchten, wollen wir sie auch exportieren können. Wir werden in diesem Kurs mehrmals Daten bereinigen und verändern und möchten diese Daten anschließend wieder in einer CSV-Datei speichern. Hierfür benutzen wir die [*write_csv*](https://readr.tidyverse.org/reference/write_delim.html)Funktion. Die Funktion *write_csv* hat zwei wichtige Argumente:

> Achte darauf, dass du die Funktion nur verwenden kannst, wenn du das Paket tidyverse geladen hast.

     write_csv(x, path)

-   x steht für den Datensatz, den wir der Funktion überführen.

-   path steht für den Dateinamen in denen wir die Datei speichern. Achte darauf, diesen Pfad immer mit Anführungsstrichen " zu umrunden.

```{=html}
<!-- -->
```
    write_csv(NAME_GEREINIGER_DATENSATZ, "datensatz_gereinigt.csv")

> R speichert die Datei immer in das aktuelle Arbeitsverzeichnis. Diese kannst du verändern, indem du mit dem Shortcut STRG + Umschalt + H (für Mac COMMAND + Umschalt + H) das Arbeitsverzeichnis wechselt. In diesen Ordner wird die Datei anschließend gespeichert.
